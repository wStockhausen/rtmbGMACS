---
title: "rtmbGMACS: CTL file formula specification"
author:
- name: William T. Stockhausen
  affiliations:
    - id: afsc-refm
      name: "Alaska Fisheries Science Center"
      department: "Resource Ecology and Fisheries Management"
      address: 
        - "7600 Sand Point Way N.E."
        - "Seattle, Washington 98115-6349"
date: '`r format(Sys.time(), "%b %e, %Y")`'
fontsize: 11pt 
number-sections: true
number-depth: 2
reference-location: document
bibliography: '`r path.expand("~/Work/Projects/Bibliography/AllRefs.bib")`'
csl: '`r system.file("files/CJFAS.csl",package="wtsQMD")`'
link-citations: true
crossref:
  chapters: false      # prepend label reference numbers by chater number?
  fig-title: Figure    # for caption: default is "Figure")
  tbl-title: Table     # for caption: default is "Table")
  title-delim: "."     # for caption: default is ":")
  fig-prefix: Figure   # for in-text (use [-@fig-ref] to drop prefix in text)
  tbl-prefix: Table    # for in-text (use [-@tbl-ref] to drop prefix in text)
  fig-labels: arabic    # options are arabic, roman, roman i, alpha x, alpha X; latter two starting from x/X
  tbl-labels: arabic    # options are arabic, roman, roman i, alpha x, alpha X; latter two starting from x/X
  subref-labels: alpha a # options are arabic, roman, roman i, alpha x, alpha X; latter two starting from x/X
  ref-hyperlink: true    # references are hyperlinked if true
format: 
  html: 
    df-print: paged
    toc: true
    toc-location: right
    fig-width: 8
    fig-asp: 0.4
    fig-dpi: 100
    embed-resources: true
    include-in-header: 
      - '`r system.file("files/in-line_math_mode.html",package="wtsQMD")`'
  pdf:
    documentclass: scrartcl
    toc: false
    fig_crop: false
    keep-tex: false
    geometry:
      - left=1.0in
      - right=1.0in
      - top=1.0in
      - bottom=1.0in
      - textwidth=6.5in
      - showframe=false
    include-in-header: 
       #include '\usepackage{nopageno}' below in header to turn off page numbering
      - text: |
          \usepackage{placeins}
          \extrafloats{500}
          \maxdeadcycles=10000
          \usepackage{fontspec}
          \usepackage{multicol}
          \usepackage{hhline}
          \newlength\Oldarrayrulewidth
          \newlength\Oldtabcolsep
          \usepackage{nopageno}
      - file: '`r system.file("files/ltx_ExtraLatexIncludes.tex",package="wtsQMD")`'
echo: false
warning: false
results: 'hide'
keep-md: true
keep-yaml: false
editor: source
editor_options: 
  chunk_output_type: console
concordance: true
params:
  setup: !expr 'system.file("files/qmd_setup.R",package="wtsQMD")'
  testing: false
  reorderTables: false   #--issue with finding "range" of table values  (don't use)
  reorderFigures: false  #--issue with finding "range" of figure values (don't use)
---
<!-- IMPORTANT: if used as a child doc, all chunk labels must be unique within the overall document -->

<!-- 
  NOTEs: 
     * child_path$peek() gives path to current script.
     * before starting a child document, do 
         "child_path$push(file.path(child_path$peek(),rel_path))" first, 
         where rel_path is the relative path to the child
     * after a child document has finished, do "child_path$pop()" to return to current path value
-->

<!-- if not child doc, set up required objects -->
```{r}
#| label: ModelCTLFormulas_setup
#| eval: !expr '!knitr::opts_knit$get("child")'
#| results: asis
  testing = params$testing;
  if (testing) cat(params$setup,"\n\n")
  source(params$setup);
  if (testing) cat("root = ",root,"\n\n")
  reorderTables  = params$reorderTables;
  reorderFigures = params$reorderFigures;
```

```{r}
#| label: setup_ModelCTLFormulas
#| results: asis
  require(rtmbGMACS);
  require(ggplot2);
  require(kableExtra);
  require(tables);
  thm = wtsPlots::getStdTheme();
  options("readr.show_col_types"=FALSE);
  if (testing) cat("dirThs =",child_path$peek(),"\n\n")
  if (!exists("tblno")) tblno = 0;#--index in LETTERS for tables in text
```

## Using formulas and model frames in function and parameter setup {#sec-CTL-File-Formulas}

One-sided `R` formulas *can* be used in the CTL file to define functions and *are* used to define parameter structures. A formula is a shorthand "recipe" which, when combined with a dataframe, allows one to create a model matrix. A formula is recognized in the CTL file as a part of a line that starts with the `~` symbol and ends with the first whitespace. Formulas are used to specify fixed effects (including covariates) and random effects, as well as to specify the covariance structure for random effects.

### "Linear" formulas

Standard formula operators can be used (`a` and `b` in the following are factors):

  * `a+b` denotes the "union" of two factors
  * `a:b` denotes the interaction of two factors
  * `a*b` expands to `a+b+a:b` and denotes full factor crossing
  * `(a+b)^k` denotes a cross to the kth degree (e.g., `(a+b)^2` = `(a+b)*(a+b)` = `a + b + a:b`)
  * `a %in% b` denotes that the terms on the left are nested within those to the right
  * the `/` operator provides a shorthand  such that a/b is equivalent to `a + b %in% a`
  * the `-` operator removes the specified term to the right
  
In addition, 

  * a formula with no "intercept" can be specified as `~0 + a` or `~a - 1`
  * a formula can involve arithmetic expressions such as `~a+log(x)`, where `x` is a numeric covariate
  * arithmetic expressions involving the operators list above should be enclosed in `I(...)` to disambiguate them from factor expressions

A "model frame" must be combined with a formula to produce a "model matrix". The model frame is a dataframe that has columns for all factors and variables/covariates in the formula. Each row of the model frame represents a particular combination of a level for each factor and a value for each variable/covariate. Each row of the model matrix provides a linear transformation from a vector of "latent" parameters resulting from the combination of the formula and model frame to the "value" of the formula associated with the corresponding row in the model frame. Base `R` and other packages (notably `Formula` and `mgcv`) provides methods to create the model matrix given a model frame and formula. The model matrix has the same number of rows as model frame, while each column corresponds to a "latent" parameter.

#### Examples

The following code sets up model dimensions for a small model
```{r}
#| label: CTL-File-Formulas-Setup
#| echo: true
vRs="EBS";
miz = as.character(seq(25,75,5));
mmz = as.character(seq(50,75,5));
fiz = as.character(seq(25,65,5));
fmz = as.character(seq(30,65,5));
vXs=list(male=list(imm=list(`new`=miz,
                             `old`=miz),
                    mat=list(`new`=mmz,
                             `old`=mmz,
                             `very`=mmz)
                  ),
          female=list(imm=list(`new`=fiz,
                               `old`=fiz),
                      mat=list(`new`=fmz,
                               `old`=fmz)
                     )
         ); attr(vXs,"dmnms")<-c("x","m","p","z");
ys = as.character(2015:2024); names(ys) = ys;
ss = as.character(1);         names(ss) = ss;
dmsC    = createSparseDimsMap(r=vRs,x=vXs);            #--DimsMap for stock categories
dmsYS   = createSparseDimsMap(y=ys,s=ss);              #--DimsMap for years and seasons
dmsYSC  = createSparseDimsMap(y=ys,s=ss,r=vRs,x=vXs);  #--DimsMap for combination 
dimsZBC = dmsC |> dplyr::mutate(lft=as.numeric(z)-2.5,mid=as.numeric(z),rgt=as.numeric(z)+2.5);
```

We also define a set of time blocks for estimating changes in survey catchability:

```{r}
#| echo: true
#--define time block for NMFS Q's
lstNMFS<-list(preCV =as.character(c(2015:2019)),       #--pre gear change
              preGC =as.character(c(2021:2022)),       #--pre gear change
              postGC=as.character(c(2023:2025)));      #--post gear change
tbNMFS = lstNMFS |> defineYearBlocks();
##--expand to dimensions map for NMFS Q's
dmsNMFS<-tbNMFS |>
         defineYearBlocks(dimsMdl=dmsYSC) |>
         dplyr::mutate(f="NMFS");
```

with the resulting `DimsMap` dataframe, `dmsNMFS` above, 

```{r}
#| label: tbl-DimsMap
#| tbl-cap: "First 60 rows of the model `DimsMap` used to create model matrices."
#| eval: !expr '(require(kableExtra))'
head(dmsNMFS,n=60) |> kableExtra::kbl(booktabs=TRUE,longtable=TRUE);
```

used as the "model frame" in conjunction with the following example formula.

### Fixed effects

```{r Formula-FixedEFfects-Crossed1}
#| echo: true
#--main effects----
##--crossed effects----
###--the model formula as text (intercept + fully-crossed model for time blocks (`yblk`) and maturity states (`m`)
f = "~1+yblk*m";
###--use `dfrNMFS` as the basis for the model frame
dfrMF = dmsNMFS;
###--create the model formula from `f`
Frmla = Formula::Formula(eval(parse(text=f)));
###--create the model frame from the formula and the basis for the model frame
MdFrm = Formula:::model.frame.Formula(Frmla,data=dfrMF);
###--define 'treatment' and 'sum' contrasts to parameters derived from `yblk` and `m` 
ctrs = list(yblk="contr.treatment",m="contr.sum");
###--convert character columns to factors and apply contrasts to model frame
dfr   = convertToDimsFactors(MdFrm,NULL,contrasts=ctrs,verbose=FALSE);
#--create the model matrix
MdMtx = Formula:::model.matrix.Formula(Frmla,data=dfr,rhs=NULL);
```

```{r}
#| label: tbl-ModelFrame1
#| tbl-cap: !expr 'paste0("Example model frame (without contrasts) for formula ",f," and basis dataframe `dmsNMFS`.")'
#| eval: !expr '(require(kableExtra))'
head(dplyr::bind_cols(MdFrm),n=60) |> kableExtra::kbl(booktabs=TRUE,longtable=TRUE);
```

::: {.callout-note appearance="simple" title="str(dfr) with 'treatment' and 'sum' contrasts" icon=false}
```{r}
#| label: ModelMatrix_ModelFrameContrasts1
#| output: markdown
  s = capture.output(str(dfr));
  cat(s,sep="\n");
  rm(s);
```
:::

```{r}
#| label: ModelMatrix_TblCap1
  tbl_cap = paste0("Example model matrix (first 60 rows) for formula ",f," and basis dataframe `dmsNMFS`, ",
                   "with 'treatment' and 'sum' contrasts applied to `yblk` and `m`, respectively. ",
                   "For reference, the model frame has been appended column-wise to the right side of the model matrix.");
```

```{r}
#| label: tbl-ModelMatrix1
#| tbl-cap: !expr 'tbl_cap'
#| eval: !expr '(require(kableExtra))'
head(dplyr::bind_cols(as.data.frame(MdMtx),MdFrm),n=60) |> kableExtra::kbl(booktabs=TRUE,longtable=TRUE);
```

```{r}
#| label: ModelMatrix_ApplyContrasts2
#| echo: true
###--define 'helmert' and 'poly' contrasts to parameters derived from `yblk` and `m`----
ctrs = list(yblk="contr.helmert",m="contr.poly");
dfr   = convertToDimsFactors(MdFrm,NULL,contrasts=ctrs,verbose=FALSE); str(dfr);
MdMtx = Formula:::model.matrix.Formula(Frmla,data=dfr,rhs=NULL);
```

::: {.callout-note appearance="simple" title="str(dfr) with 'helmert' and 'poly' contrasts applied." icon=false}
```{r}
#| label: ModelMatrix_ModelFrameContrasts2
#| output: markdown
  s = capture.output(str(dfr));
  cat(s,sep="\n");
  rm(s);
```
:::

```{r}
#| label: ModelMatrix_TblCap2
tbl_cap = paste0("Example model matrix (first 60 rows) for formula ",f," and basis dataframe `dmsNMFS`, ",
                 "with 'helmert' and 'poly' contrasts applied to `yblk` and `m`, respectively. ",
                 "For reference, the model frame has been appended column-wise to the right side of the model matrix.");
```

```{r}
#| label: tbl-ModelMatrix2
#| tbl-cap: !expr 'tbl_cap'
#| eval: !expr '(require(kableExtra))'
head(dplyr::bind_cols(as.data.frame(MdMtx),MdFrm),n=60) |> kableExtra::kbl(booktabs=TRUE,longtable=TRUE);
```

### Smooths

One-dimensional smooth functions of covariates from the `mgcv` package can also be included in a formula using the standard `mgcv` syntax by specifying the smooth function (`s` or `ti`) and the number of knots (`k`). Other potential inputs to the smooth function include specifying a "by" variable or factor and specifying the marginal basis (see [mgcv::smooth.terms] for the full list).

The following example provides the steps used in the `calcModelMatrix` function to create a model matrix from a formula that includes a smooth function and fixed effects, a dataframe from which themodel matrix is derived, and a list of contrasts specified for the factors involved in the fixed effects :

```{r}
#| label: ModelMatrix_CalcModelMatrixCode
#| echo: true
#--smooths: NEED TO USE `mgcv` package functions to do this
##--also need R package `glue` in the following
require(mgcv);
###--use `dfrNMFS` as the basis for the model frame
dfrMF = dmsNMFS;
###--create a formula (as text) with fixed effects and a smooth on size (`z`)
f0 = "~1 + yblk + s(z,k=10)"; #--the intercept term is explicitly included here for clarity
###--define 'treatment' and 'sum' contrasts to parameters derived from `yblk` and `m` 
ctrs = list(yblk="contr.treatment",m="contr.sum");
###--define symbol for model matrix
MdMtx = NULL;
###--define symbol for model frame
MdFrm = NULL;
###--extract any fixed effects
f  = removeSmoothsFromFormulaText(f0);
ns = vector("integer",0);
if (f!="~"){
  ###--create fixed factors model formula
  Frmla = Formula::Formula(eval(parse(text=f)));
  ###--create the model frame from the formula and the basis for the model frame
  MdFrm = Formula:::model.frame.Formula(Frmla,data=dfrMF);
  ###--convert character columns to factors and apply contrasts to model frame
  dfr   = convertToDimsFactors(MdFrm,NULL,contrasts=ctrs,verbose=FALSE);
  #--create the model matrix
  MdMtx = Formula:::model.matrix.Formula(Frmla,data=dfr,rhs=NULL);
  ns = ncol(MdMtx); #--number of fixed effects parameters
} #--otherwise no fixed factors

###--extract any smooths
fs  = extractSmoothsFromFormulaText(f0);
ks  = vector("integer",0);
scs = list();
if (length(fs)>0){
  for (i in 1:length(fs)){
    sso = eval(parse(text=fs[i])); #--smooth specification formula
    vrs = extractSmoothVars(fs[i]);
    vr = vrs[1]; #--numeric variable
    dfrTmp = dfrMF |> dplyr::mutate("{vr}":=as.numeric(!!rlang::sym(vr))); #--basis for model frame
    if (length(vrs)>1){
      for (j in 2:length(vrs)){
        vr = vrs[j];
        dfrTmp = dfrTmp |> dplyr::mutate("{vr}":=factor(!!rlang::sym(vr))); #--basis for model frame
      }
    }
    sc  = mgcv::smoothCon(sso,data=dfrTmp,knots=NULL);             #--smooth construct
    terms = sc[[1]]$term; #--terms (variables) for smooths
    byvar = sc[[1]]$by;   #--by variable
    scs[[f]] = sc;
    if (is.null(MdMtx)) {
      MdMtx  = sc[[1]]$X;   #--model matrix for (first) smooth term
      ks = ncol(MdMtx);     #--number of columns in the model matrix
      MdFrm = NULL;
      for (term in terms)
        MdFrm = dplyr::bind_cols(MdFrm,dfrTmp |> dplyr::select({{term}}));
      if (!is.na(byvar)) MdFrm = dplyr::bind_cols(MdFrm,dfrTmp |> dplyr::select({{byvar}}));
    } else {
      Xf = sc[[1]]$X;       #--model matrix for (first) smooth term
      ks = c(ks,ncol(Xf));  #--vector of number of terms in smooths
      MdMtx = Matrix::cbind2(MdMtx,Xf);   #--combined model matrix
      for (term in terms)
        if (!(term %in% names(MdFrm))) MdFrm = dplyr::bind_cols(MdFrm,dfrTmp |> dplyr::select({{term}}));
    }
  }#--i loop
}
```

```{r}
#| label: tbl-ModelMatrixSmooth1
#| tbl-cap: 'Example model matrix for the (text) formula "~1 + yblk + s(z,k=10)", where `s(...)` is the smooth `mgcv::s(...)` function.'
#| eval: !expr '(require(kableExtra))'
head(as.data.frame(MdMtx),n=60) |> kableExtra::kbl(booktabs=TRUE,longtable=TRUE);
```

```{r}
#| label: ModelMatrix_CalcModelMatrix
#| echo: true
#| results: asis
  res = calcModelMatrix(f0,dfrMF,ctrs);
```

```{r}
#| label: tbl-ModelMatrixSmooth1a
#| tbl-cap: "Model matrix from previous example using `calcModelMarix` function."
#| eval: !expr '(require(kableExtra))'
head(as.data.frame(res$ModMtx),n=60) |> kableExtra::kbl(booktabs=TRUE,longtable=TRUE);
```

Here is an example with a smooth function including a "by" variable, but without fixed effects (and thus without contrasts): 

```{r}
#| label: ModelMatrix_SmoothWithBy
#| echo: true
##--single s() smooth, with by variable
  txt = "~s(z,k=10,by=yblk)";
  res = calcModelMatrix(txt,dfrMF);
```

```{r}
#| label: tbl-ModelMatrixSmooth2
#| tbl-cap: 'Example model matrix for a single `mgcv` smooth with a "by" variable: "~s(z,k=10,by=yblk)".'
#| eval: !expr '(require(kableExtra))'
  head(as.data.frame(res$ModMtx),n=60) |> kableExtra::kbl(booktabs=TRUE,longtable=TRUE);
```

The previous examples included a smooth function of size `z` using `mgcv`'s `s` function. In the following, the `ti` (tensor interaction) function is used with a "factor smooth" basis to estimate "random wiggly" smooths on size for each year `y`.
```{r}
#| label: ModelMatrix_SmoothWithFS
#| echo: true
##--single ti() smooth, with "fs" basis ("factor smoothing") resulting in a "random" wiggly curve estimated for each level of y
  txt = "~s(z,y,k=10,bs='fs')";
  res = calcModelMatrix(txt,dfrMF);
```

```{r}
#| label: tbl-ModelMatrixSmooth5
#| tbl-cap: 
#|   "Example model matrix for a smooth term `mgcv::ti(z,y,k=10,bs='fs')`. `z` (size) is a numeric variable, `y` (year) is a factor, and `bs='fs'` specifies a 'factor smooth' with a 'wiggly' function of size created for every level of `y`."
#| eval: !expr '(require(kableExtra))'
  head(as.data.frame(res$ModMtx),n=60) |> kableExtra::kbl(booktabs=TRUE,longtable=TRUE);
```

```{r}
#| label: ModelMatrix_REs
#--random effects
```

```{r}
#| label: refs_ModelCTLFormulas
#| eval: !expr '!knitr::opts_knit$get("child")'
#| results: asis
  cat("# References {-}\n")
  cat("::: {#refs}\n")
  cat(":::\n\n")
```

<!-- tables, if not child doc and lstTbls is not empty -->
```{r}
#| label: tables_ModelCTLFormulas
#| eval: !expr '!knitr::opts_knit$get("child")'
#| results: asis
  source(system.file("files/printTablesSectionFromList.R",package="wtsQMD"));
```

<!-- figures, if not child doc and lstFigs is not empty -->
```{r}
#| label: figures_ModelCTLFormulas
#| eval: !expr '!knitr::opts_knit$get("child")'
#| results: asis
  source(system.file("files/printFiguresSectionFromList.R",package="wtsQMD"));
```

